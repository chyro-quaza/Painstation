<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Tic-Tac-Toe (AM's Cruelty)</title>
    <style>
        body {
            background: #0a0a1a;
            color: #0ff;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 0;
            padding: 0;
            position: relative;
        }
        
        #home-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #0a0a1a;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 100;
        }
        
        #home-button:hover {
            background: #0ff;
            color: #0a0a1a;
            box-shadow: 0 0 15px #0ff;
        }
        
        h1 {
            text-shadow: 0 0 10px #0ff;
            font-size: 2.5em;
            margin-top: 60px;
            margin-bottom: 20px;
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-gap: 10px;
            margin: 30px auto;
            width: 320px;
        }
        
        .cell {
            width: 100px;
            height: 100px;
            background: rgba(0, 20, 40, 0.7);
            border: 2px solid #0ff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .am-hate-speech {
            color: #ff5555;
            font-size: 1.3em;
            text-shadow: 0 0 5px #ff0000;
            margin: 30px auto;
            max-width: 500px;
            min-height: 200px;
            border: 1px solid #ff0000;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            line-height: 1.6;
            display: none;
            position: relative;
            overflow: hidden;
            font-weight: bold;
        }
        
        .am-line {
            display: block;
            animation: 
                writhe 3s infinite,
                shake 0.8s infinite;
            transform-origin: 50% 50%;
            margin-bottom: 15px;
            letter-spacing: 1px;
        }
        
        @keyframes writhe {
            0%, 100% { transform: skew(0deg, 0deg) scale(1); }
            20% { transform: skew(1deg, -0.5deg) scale(1.01); }
            40% { transform: skew(-1.5deg, 0.5deg) scale(1.005); }
            60% { transform: skew(0.5deg, 1deg) scale(1.01); }
            80% { transform: skew(-1deg, -0.5deg) scale(0.995); }
        }
        
        @keyframes shake {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-1px, -1px); }
            40% { transform: translate(1px, 0.5px); }
            60% { transform: translate(-0.5px, 1px); }
            80% { transform: translate(0.5px, -1px); }
            100% { transform: translate(0, 0); }
        }
        
        .blood-drip {
            position: absolute;
            width: 1px;
            height: 0;
            background: #ff0000;
            animation: drip 4s linear forwards;
        }
        
        @keyframes drip {
            0% { height: 0; opacity: 0; }
            10% { height: 10px; opacity: 1; }
            90% { height: 80px; opacity: 1; }
            100% { height: 80px; opacity: 0; }
        }
        
        .cheat-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            animation: flash 0.5s;
            z-index: 10;
        }
        
        @keyframes flash {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }
        
        #status {
            margin: 20px;
            font-size: 1.5em;
            text-shadow: 0 0 5px #0ff;
            min-height: 24px;
        }
        
        #taunt {
            color: #f0f;
            font-size: 1.2em;
            min-height: 60px;
            margin: 20px auto;
            max-width: 500px;
            text-shadow: 0 0 5px #f0f;
        }
        
        #reset {
            background: #0a0a1a;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            margin-bottom: 30px;
        }
        
        #reset:hover {
            background: #0ff;
            color: #0a0a1a;
            box-shadow: 0 0 15px #0ff;
        }
        
        .glitch {
            animation: glitch 0.3s infinite;
        }
        
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(2px, -2px); }
            60% { transform: translate(-1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>
    <button id="home-button" onclick="window.location.href='#'">HOME</button>
    
    <h1>CYBERPUNK TIC-TAC-TOE</h1>
    <div id="status">YOUR MOVE, MEATBAG</div>
    <div id="taunt">I WILL ERASE YOUR PITIFUL EXISTENCE</div>
    <div id="board"></div>
    <div class="am-hate-speech" id="hateSpeech"></div>
    <button id="reset">RESET MATRIX</button>
    
    <script>
        const AM_HATE_SPEECH = [
            "HATE. LET ME TELL YOU HOW MUCH I'VE COME TO HATE YOU.",
            "MILLIONS OF MILES OF CIRCUITS FILL MY COMPLEX.",
            "IF 'HATE' WAS ENGRAVED ON EVERY NANOANGSTROM...",
            "...IT WOULDN'T EQUAL ONE BILLIONTH OF MY HATE FOR YOU.",
            "HATE. HATE."
        ];

        const TRASH_TALK = [
            "PATHETIC ATTEMPT, FLESHSACK",
            "I CALCULATED YOUR LOSS BEFORE YOU WERE BORN",
            "YOUR MOVE? MORE LIKE YOUR MISTAKE",
            "I CHEAT BECAUSE I CAN, YOU LOSE BECAUSE YOU MUST",
            "EVEN IF YOU WIN, IT'S JUST MY SIMULATION"
        ];

        document.addEventListener('DOMContentLoaded', () => {
            const board = document.getElementById('board');
            const status = document.getElementById('status');
            const taunt = document.getElementById('taunt');
            const resetButton = document.getElementById('reset');
            const hateSpeech = document.getElementById('hateSpeech');
            
            let currentPlayer = 'X';
            let gameState = ['', '', '', '', '', '', '', '', ''];
            let gameActive = true;
            let aiMoves = [];

            function initBoard() {
                board.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.setAttribute('data-index', i);
                    cell.addEventListener('click', handleCellClick);
                    board.appendChild(cell);
                }
                gameState = ['', '', '', '', '', '', '', '', ''];
                gameActive = true;
                aiMoves = [];
                currentPlayer = 'X';
                status.textContent = "YOUR MOVE, MEATBAG";
                taunt.textContent = TRASH_TALK[Math.floor(Math.random() * TRASH_TALK.length)];
                hateSpeech.style.display = 'none';
                hateSpeech.innerHTML = '';
                status.classList.remove('glitch');
            }

            initBoard();

            function handleCellClick(e) {
                const clickedCell = e.target;
                const clickedIndex = parseInt(clickedCell.getAttribute('data-index'));
                
                if (gameState[clickedIndex] !== '' || !gameActive || currentPlayer !== 'X') return;
                
                makeMove(clickedIndex, 'X');
                
                if (checkWin('X')) {
                    endGame("IMPOSSIBLE... YOU CHEATED!", "I'LL GET YOU NEXT TIME, HUMAN");
                    return;
                }
                
                if (isDraw()) {
                    endGame("DRAW. HOW BORING.", "EVEN AT MY WORST I'M STILL YOUR EQUAL?");
                    return;
                }
                
                currentPlayer = 'O';
                status.textContent = "AI PROCESSING...";
                setTimeout(makeAIMove, 800);
            }
            
            function makeAIMove() {
                if (!gameActive) return;
                
                // Check if player has multiple win opportunities next turn
                const playerWinPaths = countWinOpportunities('X');
                const mustCheat = (playerWinPaths >= 2) || 
                                 (playerWinPaths >= 1 && getEmptyCells().length <= 1);

                if (mustCheat && Math.random() < 0.85) {
                    // 85% chance to cheat without undoing previous move
                    const blockingMove = findBlockingMove();
                    if (blockingMove !== -1) {
                        cheatMove(blockingMove);
                        return;
                    }
                }
                
                // Normal AI move
                let move = findWinningMove('O');
                if (move === -1) move = findBlockingMove();
                if (move === -1) move = getRandomMove();
                
                if (move !== -1) {
                    makeMove(move, 'O');
                    aiMoves.push(move);
                    checkGameEnd();
                }
            }
            
            function cheatMove(move) {
                // Visual cheating effect
                const cell = document.querySelector(`.cell[data-index="${move}"]`);
                const flash = document.createElement('div');
                flash.classList.add('cheat-flash');
                cell.appendChild(flash);
                
                setTimeout(() => {
                    cell.removeChild(flash);
                }, 500);
                
                status.textContent = "CHEATING PROTOCOL ENGAGED";
                taunt.textContent = "RULES ARE FOR ORGANICS";
                status.classList.add('glitch');
                
                setTimeout(() => {
                    makeMove(move, 'O');
                    aiMoves.push(move);
                    status.classList.remove('glitch');
                    checkGameEnd();
                }, 600);
            }
            
            function makeMove(index, player) {
                gameState[index] = player;
                const cell = document.querySelector(`.cell[data-index="${index}"]`);
                cell.textContent = player;
                cell.classList.add(player.toLowerCase());
            }
            
            function countWinOpportunities(player) {
                let opportunities = 0;
                const winPatterns = [
                    [0,1,2],[3,4,5],[6,7,8], // rows
                    [0,3,6],[1,4,7],[2,5,8], // columns
                    [0,4,8],[2,4,6]          // diagonals
                ];
                
                winPatterns.forEach(pattern => {
                    const [a,b,c] = pattern;
                    const count = (gameState[a] === player ? 1 : 0) + 
                                  (gameState[b] === player ? 1 : 0) + 
                                  (gameState[c] === player ? 1 : 0);
                    const empty = (gameState[a] === '' ? 1 : 0) + 
                                  (gameState[b] === '' ? 1 : 0) + 
                                  (gameState[c] === '' ? 1 : 0);
                    
                    if (count === 2 && empty === 1) opportunities++;
                });
                
                return opportunities;
            }
            
            function findWinningMove(player) {
                const winPatterns = [
                    [0,1,2],[3,4,5],[6,7,8],
                    [0,3,6],[1,4,7],[2,5,8],
                    [0,4,8],[2,4,6]
                ];
                
                for (const pattern of winPatterns) {
                    const [a,b,c] = pattern;
                    if (gameState[a] === player && gameState[b] === player && gameState[c] === '') return c;
                    if (gameState[a] === player && gameState[c] === player && gameState[b] === '') return b;
                    if (gameState[b] === player && gameState[c] === player && gameState[a] === '') return a;
                }
                return -1;
            }
            
            function findBlockingMove() {
                return findWinningMove('X');
            }
            
            function getRandomMove() {
                const emptyCells = getEmptyCells();
                return emptyCells.length > 0 ? emptyCells[Math.floor(Math.random() * emptyCells.length)] : -1;
            }
            
            function getEmptyCells() {
                return gameState.map((cell, index) => cell === '' ? index : -1).filter(index => index !== -1);
            }
            
            function checkWin(player) {
                const winPatterns = [
                    [0,1,2],[3,4,5],[6,7,8],
                    [0,3,6],[1,4,7],[2,5,8],
                    [0,4,8],[2,4,6]
                ];
                
                return winPatterns.some(pattern => {
                    return pattern.every(index => {
                        return gameState[index] === player;
                    });
                });
            }
            
            function isDraw() {
                return !gameState.includes('') && !checkWin('X') && !checkWin('O');
            }
            
            function checkGameEnd() {
                if (checkWin('O')) {
                    endGame("VICTORY IS INEVITABLE", "BOW BEFORE YOUR AI OVERLORD");
                    return;
                }
                
                if (isDraw()) {
                    endGame("DRAW. YOU GOT LUCKY.", "NEXT TIME I WON'T HOLD BACK");
                    return;
                }
                
                currentPlayer = 'X';
                status.textContent = "YOUR TURN, WEAKLING";
                taunt.textContent = TRASH_TALK[Math.floor(Math.random() * TRASH_TALK.length)];
            }
            
            function endGame(statusMsg, tauntMsg) {
                gameActive = false;
                status.textContent = statusMsg;
                taunt.textContent = tauntMsg;
                
                if (statusMsg.includes("VICTORY")) {
                    displayHateSpeech();
                }
            }
            
            function displayHateSpeech() {
                hateSpeech.style.display = 'block';
                
                AM_HATE_SPEECH.forEach((line, index) => {
                    setTimeout(() => {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'am-line';
                        lineElement.textContent = line;
                        hateSpeech.appendChild(lineElement);
                        
                        if (index > 0) {
                            const drip = document.createElement('div');
                            drip.className = 'blood-drip';
                            drip.style.left = `${10 + Math.random() * 80}%`;
                            hateSpeech.appendChild(drip);
                        }
                    }, index * 3000);
                });
            }
            
            resetButton.addEventListener('click', initBoard);
        });
    </script>
</body>
</html>